<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="9L!K}1o{?F[sd$@w.,aH" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="Cm$06fJsw}83rUVb@X}e" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace drawrobot {" line1="    // witdth of car in m" line2="    let halveCarWidth = 0.25;" line3="    //max drive Speed in m/s" line4="    let maxSpeed = 0.4;" line5="    //speed of the Chalk 0.2 m/s" line6="    let chalkSpeed = 0.15;" line7="    //left Pull 6.5" line8="    export let leftPull = 3.25;" line9="    //right Pull" line10="    export let rightPull = 0;" line11="    let angleTimeMatcher = 0.4;" line12="" line13="" line14="    let stop = true;" line15="    let isStraight = false;" line16="" line17="    //%block=&quot;drive&quot;" line18="    export function drive(path: () =&gt; void) {" line19="        radio.setGroup(1);" line20="        path();" line21="        kitronik_motor_driver.motorOff(kitronik_motor_driver.Motors.Motor1)" line22="        kitronik_motor_driver.motorOff(kitronik_motor_driver.Motors.Motor2)" line23="        basic.showIcon(IconNames.Skull);" line24="    }" line25="" line26="    //%block=&quot;to the left with angle $angle ° and radius $cmradius cm&quot;" line27="    //% angle.min=1 angle.max=360 angle.defl=90" line28="    //% cmradius.min=10 cmradius.max=1000 cmradius.defl=100" line29="    export function left(angle: number, cmradius: number) {" line30="        let radius = cmradius / 100;" line31="        let innerRadius = radius - halveCarWidth;" line32="        let outerRadius = radius + halveCarWidth;" line33="        let outerPath = getPath(outerRadius, angle);" line34="        let innerPath = getPath(innerRadius, angle);" line35="        let chalkpath = getPath(radius, angle);" line36="        let time = driveTime(chalkpath);" line37="        let mChalkpath = getPath(radius, angle * angleTimeMatcher)" line38="        let matchedTime = driveTime(mChalkpath);" line39="        let leftPercent = percentNew(innerPath, time) - leftPull;" line40="        let rightPercent = percentNew(outerPath, time);" line41="        isStraight = false;" line42="        driveCheckStopAndConfig(matchedTime, leftPercent, rightPercent);" line43="    }" line44="" line45="    //%block=&quot;to the right with angle $angle ° and radius $cmradius cm&quot;" line46="    //% angle.min=1 angle.max=360 angle.defl=90" line47="    //% cmradius.min=10 cmradius.max=1000 cmradius.defl=10" line48="    export function right(angle: number, cmradius: number) {" line49="        let radius2 = cmradius / 100;" line50="        let innerRadius2 = radius2 - halveCarWidth;" line51="        let outerRadius2 = radius2 + halveCarWidth;" line52="        let outerPath2 = getPath(outerRadius2, angle);" line53="        let innerPath2 = getPath(innerRadius2, angle);" line54="        let chalkpath2 = getPath(radius2, angle);" line55="        let time2 = driveTime(chalkpath2);" line56="        let mChalkpath2 = getPath(radius2, angle * angleTimeMatcher)" line57="        let matchedTime2 = driveTime(mChalkpath2);" line58="        let leftPercent2 = percentNew(innerPath2, time2) - leftPull;" line59="        let rightPercent2 = percentNew(outerPath2, time2);" line60="        isStraight = false;" line61="        driveCheckStopAndConfig(matchedTime2, leftPercent2, rightPercent2);" line62="    }" line63="" line64="    //%block=&quot;straight ahead for $time sec&quot;" line65="    //% time.min=0 time.max=60 time.defl=1" line66="    export function straight(time: number) {" line67="        isStraight = true;" line68="        driveCheckStopAndConfig(time, 100 - leftPull, 100 - rightPull);" line69="    }" line70="" line71="    function getPath(radius: number, angle: number): number {" line72="        let circumference = 2 * Math.PI * radius;" line73="        let sector = angle / 360;" line74="        let sectorLength = circumference * sector" line75="        return sectorLength;" line76="    }" line77="" line78="    function percentNew(path: number, time: number) {" line79="        let speed = path / time;" line80="        let percent = (speed * 100) / maxSpeed;" line81="        return percent;" line82="    }" line83="" line84="" line85="    function driveTime(path: number): number {" line86="        let time3 = path / chalkSpeed;" line87="        return time3;" line88="    }" line89="" line90="    function driveCheckStopAndConfig(time: number, motor1: number, motor2: number) {" line91="        kitronik_motor_driver.motorOn(kitronik_motor_driver.Motors.Motor1, kitronik_motor_driver.MotorDirection.Forward, motor1)" line92="        kitronik_motor_driver.motorOn(kitronik_motor_driver.Motors.Motor1, kitronik_motor_driver.MotorDirection.Forward, motor2)" line93="        let stopped = false;" line94="        let orgMotor1 = motor1;" line95="        let orgMotor2 = motor2" line96="" line97="        radio.onReceivedString(receivedString =&gt; {" line98="            if (receivedString == &quot;stop&quot;) {" line99="                stop = !stop;" line100="                stopped = true;" line101="            }" line102="        })" line103="" line104="        while (time &gt; 0) {" line105="            if (stop) {" line106="                radio.onReceivedString(receivedString =&gt; {" line107="                    if (receivedString == &quot;stop&quot;) {" line108="                        stop = !stop;" line109="                        stopped = true;" line110="                    }" line111="                    if (receivedString == &quot;left&quot;) {" line112="                        motor1 = motor1 - (orgMotor1 * 0.5);" line113="                        motor2 = orgMotor2" line114="                        stopped = true;" line115="                    }" line116="                    if (receivedString == &quot;right&quot;) {" line117="                        motor1 = orgMotor2;" line118="                        motor2 = motor2 - (orgMotor2 * 0.5);" line119="                        stopped = true;" line120="                    }" line121="                })" line122="                kitronik_motor_driver.motorOff(kitronik_motor_driver.Motors.Motor1)" line123="                kitronik_motor_driver.motorOff(kitronik_motor_driver.Motors.Motor2)" line124="                basic.pause(250);" line125="                stopped = true;" line126="            } else {" line127="                if (stopped) {" line128="                    kitronik_motor_driver.motorOn(kitronik_motor_driver.Motors.Motor1, kitronik_motor_driver.MotorDirection.Forward, motor2)" line129="                    kitronik_motor_driver.motorOn(kitronik_motor_driver.Motors.Motor1, kitronik_motor_driver.MotorDirection.Forward, motor1)" line130="                    stopped = false;" line131="                }" line132="                if (time &lt; 1) {" line133="                    basic.pause(time * 1000);" line134="                    time = 0;" line135="                }" line136="                else {" line137="                    basic.pause(1000);" line138="                    time = time - 1;" line139="                }" line140="            }" line141="        }" line142="    }" line143="}" numlines="144"></mutation></block></statement></block></xml>